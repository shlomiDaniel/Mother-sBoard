import { Directive, ElementRef, Component, Input, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatTable, MatTableDataSource, MatColumnDef, MatCellDef, MatHeaderCellDef, MatTableModule } from '@angular/material/table';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { moveItemInArray, DragDrop } from '@angular/cdk/drag-drop';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/material/table';
import * as ɵngcc2 from '@angular/cdk/drag-drop';
import * as ɵngcc3 from '@angular/material/checkbox';

function MatSelectionColumnComponent_th_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 3);
    ɵngcc0.ɵɵelementStart(1, "mat-checkbox", 4);
    ɵngcc0.ɵɵlistener("change", function MatSelectionColumnComponent_th_1_Template_mat_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return $event ? ctx_r2.masterToggle() : null; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", (ctx_r0.selection == null ? null : ctx_r0.selection.hasValue()) && ctx_r0.isAllSelected())("indeterminate", (ctx_r0.selection == null ? null : ctx_r0.selection.hasValue()) && !ctx_r0.isAllSelected());
} }
function MatSelectionColumnComponent_td_2_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵelementStart(1, "mat-checkbox", 6);
    ɵngcc0.ɵɵlistener("click", function MatSelectionColumnComponent_td_2_Template_mat_checkbox_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); return $event.stopPropagation(); })("change", function MatSelectionColumnComponent_td_2_Template_mat_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const row_r4 = ctx.$implicit; const ctx_r7 = ɵngcc0.ɵɵnextContext(); return $event ? ctx_r7.selection == null ? null : ctx_r7.selection.toggle(row_r4) : null; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r4 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", ctx_r1.selection == null ? null : ctx_r1.selection.isSelected(row_r4));
} }
class CustomHeaderDirective {
    constructor(table, headerRow, dndService) {
        this.table = table;
        this.headerRow = headerRow;
        this.dndService = dndService;
        this.columns = [];
    }
    ngAfterViewInit() {
        this.dropListRef = this.createDropList(this.headerRow, this.createDrags(this.getHeaderCells(this.headerRow.nativeElement)));
        this.columns = this.table._contentHeaderRowDefs.first.columns;
        console.log(this.columns);
    }
    drop(event) {
        moveItemInArray(this.columns, event.previousIndex, event.currentIndex);
    }
    getHeaderCells(rowElem) {
        return Array.from(rowElem.children);
    }
    createDrags(cellRefs) {
        return cellRefs.map((cellRef) => {
            const drag = this.dndService.createDrag(cellRef);
            drag.lockAxis = 'x';
            return drag;
        });
    }
    createDropList(headerRowDef, drags) {
        const dropListRef = this.dndService.createDropList(headerRowDef);
        dropListRef.withItems(drags);
        dropListRef.withOrientation('horizontal');
        dropListRef.dropped.subscribe((event) => this.drop(event));
        return dropListRef;
    }
}
CustomHeaderDirective.ɵfac = function CustomHeaderDirective_Factory(t) { return new (t || CustomHeaderDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MatTable), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DragDrop)); };
CustomHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CustomHeaderDirective, selectors: [["", "matCustomHeader", ""]] });
CustomHeaderDirective.ctorParameters = () => [
    { type: MatTable },
    { type: ElementRef },
    { type: DragDrop }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[matCustomHeader]'
            }]
    }], function () { return [{ type: ɵngcc1.MatTable }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.DragDrop }]; }, null); })();

class MatSelectionColumnComponent {
    constructor(table) {
        this.table = table;
    }
    ngOnInit() {
        this.columnDef.name = this.name || 'select';
        this.columnDef.cell = this.cell;
        this.columnDef.headerCell = this.headerCell;
        this.table.addColumnDef(this.columnDef);
    }
    ngOnDestroy() {
        this.table.removeColumnDef(this.columnDef);
    }
    get data() {
        if (!this.table) {
            return [];
        }
        if (this.table.dataSource instanceof MatTableDataSource) {
            return this.table.dataSource.data || [];
        }
        // TODO: What about Observables?
        return this.table.dataSource || [];
    }
    /** Whether the number of selected elements matches the total number of rows. */
    isAllSelected() {
        var _a;
        const numSelected = ((_a = this.selection) === null || _a === void 0 ? void 0 : _a.selected.length) || 0;
        const numRows = this.data.length;
        return numSelected === numRows;
    }
    /** Selects all rows if they are not all selected; otherwise clear selection. */
    masterToggle() {
        if (!this.selection) {
            return;
        }
        this.isAllSelected() ?
            this.selection.clear() :
            this.selection.select(...this.data);
    }
}
MatSelectionColumnComponent.ɵfac = function MatSelectionColumnComponent_Factory(t) { return new (t || MatSelectionColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MatTable)); };
MatSelectionColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSelectionColumnComponent, selectors: [["mat-selection-column"]], viewQuery: function MatSelectionColumnComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(MatColumnDef, true);
        ɵngcc0.ɵɵstaticViewQuery(MatCellDef, true);
        ɵngcc0.ɵɵstaticViewQuery(MatHeaderCellDef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnDef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);
    } }, inputs: { name: "name", selection: "selection" }, decls: 3, vars: 0, consts: [["matColumnDef", ""], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-cell", "", 4, "matCellDef"], ["mat-header-cell", ""], [3, "checked", "indeterminate", "change"], ["mat-cell", ""], [3, "checked", "click", "change"]], template: function MatSelectionColumnComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, MatSelectionColumnComponent_th_1_Template, 2, 2, "th", 1);
        ɵngcc0.ɵɵtemplate(2, MatSelectionColumnComponent_td_2_Template, 2, 1, "td", 2);
        ɵngcc0.ɵɵelementContainerEnd();
    } }, directives: [ɵngcc1.MatColumnDef, ɵngcc1.MatHeaderCellDef, ɵngcc1.MatCellDef, ɵngcc1.MatHeaderCell, ɵngcc3.MatCheckbox, ɵngcc1.MatCell], styles: [".mat-cell[_ngcontent-%COMP%], .mat-header-cell[_ngcontent-%COMP%]{padding-left:24px;padding-right:24px}"] });
MatSelectionColumnComponent.ctorParameters = () => [
    { type: MatTable }
];
MatSelectionColumnComponent.propDecorators = {
    name: [{ type: Input }],
    selection: [{ type: Input }],
    columnDef: [{ type: ViewChild, args: [MatColumnDef, { static: true },] }],
    cell: [{ type: ViewChild, args: [MatCellDef, { static: true },] }],
    headerCell: [{ type: ViewChild, args: [MatHeaderCellDef, { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSelectionColumnComponent, [{
        type: Component,
        args: [{
                selector: 'mat-selection-column',
                template: "<ng-container matColumnDef>\n  <th mat-header-cell *matHeaderCellDef>\n    <mat-checkbox (change)=\"$event ? masterToggle() : null\"\n                  [checked]=\"selection?.hasValue() && isAllSelected()\"\n                  [indeterminate]=\"selection?.hasValue() && !isAllSelected()\">\n    </mat-checkbox>\n  </th>\n  <td mat-cell *matCellDef=\"let row\">\n    <mat-checkbox (click)=\"$event.stopPropagation()\"\n                  (change)=\"$event ? selection?.toggle(row) : null\"\n                  [checked]=\"selection?.isSelected(row)\">\n    </mat-checkbox>\n  </td>\n</ng-container>\n",
                styles: [".mat-cell,.mat-header-cell{padding-left:24px;padding-right:24px}"]
            }]
    }], function () { return [{ type: ɵngcc1.MatTable }]; }, { name: [{
            type: Input
        }], selection: [{
            type: Input
        }], columnDef: [{
            type: ViewChild,
            args: [MatColumnDef, { static: true }]
        }], cell: [{
            type: ViewChild,
            args: [MatCellDef, { static: true }]
        }], headerCell: [{
            type: ViewChild,
            args: [MatHeaderCellDef, { static: true }]
        }] }); })();

/** @description Exports all the extensions for material's table component. */
class MatTableExtensionsModule {
}
MatTableExtensionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatTableExtensionsModule });
MatTableExtensionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatTableExtensionsModule_Factory(t) { return new (t || MatTableExtensionsModule)(); }, imports: [[
            CommonModule,
            MatTableModule,
            MatCheckboxModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatTableExtensionsModule, { declarations: function () { return [CustomHeaderDirective, MatSelectionColumnComponent]; }, imports: function () { return [CommonModule,
        MatTableModule,
        MatCheckboxModule]; }, exports: function () { return [CustomHeaderDirective, MatSelectionColumnComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTableExtensionsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CustomHeaderDirective,
                    MatSelectionColumnComponent
                ],
                imports: [
                    CommonModule,
                    MatTableModule,
                    MatCheckboxModule
                ],
                exports: [
                    CustomHeaderDirective,
                    MatSelectionColumnComponent
                ]
            }]
    }], null, null); })();

// module

/*
 * Public API Surface of extensions
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CustomHeaderDirective, MatSelectionColumnComponent, MatTableExtensionsModule };

//# sourceMappingURL=angular-material-extensions.js.map