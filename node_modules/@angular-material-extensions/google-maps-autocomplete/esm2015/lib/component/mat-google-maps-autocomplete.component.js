import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@agm/core';
import * as ɵngcc2 from '@angular/material/form-field';
import * as ɵngcc3 from '@angular/material/input';
import * as ɵngcc4 from '@angular/forms';
import * as ɵngcc5 from '../directives/address-validator/mat-address-validator.directive';
import * as ɵngcc6 from '@angular/common';

const _c0 = ["search"];
function MatGoogleMapsAutocompleteComponent_mat_error_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-error");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.requiredErrorText, " ");
} }
function MatGoogleMapsAutocompleteComponent_mat_error_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-error");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.invalidErrorText, " ");
} }
var MatGoogleMapsAutocompleteComponent_1;
import { __decorate } from "tslib";
import { Component, ElementRef, EventEmitter, forwardRef, Input, NgZone, OnInit, Output, ViewChild } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { MapsAPILoader } from '@agm/core';
import { MatValidateAddressDirective } from '../directives/address-validator/mat-address-validator.directive';
export var Appearance;
(function (Appearance) {
    Appearance["STANDARD"] = "standard";
    Appearance["FILL"] = "fill";
    Appearance["OUTLINE"] = "outline";
    Appearance["LEGACY"] = "legacy";
})(Appearance || (Appearance = {}));
let MatGoogleMapsAutocompleteComponent = MatGoogleMapsAutocompleteComponent_1 = class MatGoogleMapsAutocompleteComponent {
    constructor(mapsAPILoader, ngZone) {
        this.mapsAPILoader = mapsAPILoader;
        this.ngZone = ngZone;
        this.addressLabelText = 'Address';
        this.placeholderText = 'Please enter the address';
        this.requiredErrorText = 'The address is required';
        this.invalidErrorText = 'The address is not valid';
        this.appearance = Appearance.STANDARD;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onGermanAddressMapped = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
        this.propagateChange = (_) => {
        };
    }
    ngOnInit() {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        const options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    }
    initGoogleMapsAutocomplete() {
        this.mapsAPILoader
            .load()
            .then(() => {
            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);
            autocomplete.addListener('place_changed', () => {
                this.ngZone.run(() => {
                    // get the place result
                    const place = autocomplete.getPlace();
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    place.address_components.forEach(value => {
                        if (value.types.indexOf('street_number') > -1) {
                            germanAddress.streetNumber = value.short_name;
                        }
                        if (value.types.indexOf('route') > -1) {
                            germanAddress.streetName = value.long_name;
                        }
                        if (value.types.indexOf('postal_code') > -1) {
                            germanAddress.postalCode = Number(value.short_name);
                        }
                        if (value.types.indexOf('sublocality') > -1) {
                            germanAddress.sublocality = value.long_name;
                        }
                        if (value.types.indexOf('locality') > -1) {
                            germanAddress.locality.long = value.long_name;
                            germanAddress.locality.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_1') > -1) {
                            germanAddress.state.long = value.long_name;
                            germanAddress.state.short = value.short_name;
                        }
                        if (value.types.indexOf('country') > -1) {
                            germanAddress.country.long = value.long_name;
                            germanAddress.country.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_3') > -1) {
                            germanAddress.locality.short = value.short_name;
                        }
                    });
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                        this.value = place;
                        this.propagateChange(this.value);
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    // console.log('onAutocompleteSelected -> ', place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                });
            });
        })
            .catch((err) => console.log(err));
    }
    onQuery(event) {
        // console.log('onChange()', event);
        this.onChange.emit(this.address);
    }
    resetAddress() {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    }
    writeValue(obj) {
        if (obj) {
            this.value = obj;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        throw new Error('Method not implemented.');
    }
    setDisabledState(isDisabled) {
        throw new Error('Method not implemented.');
    }
};
MatGoogleMapsAutocompleteComponent.ɵfac = function MatGoogleMapsAutocompleteComponent_Factory(t) { return new (t || MatGoogleMapsAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MapsAPILoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MatGoogleMapsAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatGoogleMapsAutocompleteComponent, selectors: [["mat-google-maps-autocomplete"]], viewQuery: function MatGoogleMapsAutocompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchElementRef = _t.first);
    } }, inputs: { addressLabelText: "addressLabelText", placeholderText: "placeholderText", requiredErrorText: "requiredErrorText", invalidErrorText: "invalidErrorText", appearance: "appearance", autoCompleteOptions: "autoCompleteOptions", value: "value", address: "address", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type" }, outputs: { onChange: "onChange", onAutocompleteSelected: "onAutocompleteSelected", onGermanAddressMapped: "onGermanAddressMapped", onLocationSelected: "onLocationSelected" }, exportAs: ["matGoogleMapsAutocomplete"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent_1),
                multi: true
            }
        ])], decls: 7, vars: 6, consts: [[1, "full-width", 3, "appearance"], ["matInput", "", "MatValidateAddress", "", "required", "", 1, "form-control", 3, "ngModel", "placeholder", "ngModelChange", "change"], ["search", ""], [4, "ngIf"]], template: function MatGoogleMapsAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-form-field", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-label");
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MatGoogleMapsAutocompleteComponent_Template_input_ngModelChange_3_listener($event) { return ctx.address = $event; })("change", function MatGoogleMapsAutocompleteComponent_Template_input_change_3_listener($event) { return ctx.onQuery($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, MatGoogleMapsAutocompleteComponent_mat_error_5_Template, 2, 1, "mat-error", 3);
        ɵngcc0.ɵɵtemplate(6, MatGoogleMapsAutocompleteComponent_mat_error_6_Template, 2, 1, "mat-error", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.addressLabelText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵpropertyInterpolate("placeholder", ctx.placeholderText);
        ɵngcc0.ɵɵproperty("ngModel", ctx.address);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.addressSearchControl.hasError("required"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.addressSearchControl.hasError("validateAddress"));
    } }, directives: [ɵngcc2.MatFormField, ɵngcc2.MatLabel, ɵngcc3.MatInput, ɵngcc4.DefaultValueAccessor, ɵngcc5.MatValidateAddressDirective, ɵngcc4.RequiredValidator, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc6.NgIf, ɵngcc2.MatError], styles: [".full-width[_ngcontent-%COMP%]{width:100%}"] });
MatGoogleMapsAutocompleteComponent.ctorParameters = () => [
    { type: MapsAPILoader },
    { type: NgZone }
];
__decorate([
    ViewChild('search')
], MatGoogleMapsAutocompleteComponent.prototype, "searchElementRef", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "addressLabelText", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "placeholderText", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "requiredErrorText", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "invalidErrorText", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "appearance", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "value", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "address", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "country", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "placeIdOnly", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "strictBounds", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "types", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "type", void 0);
__decorate([
    Input()
], MatGoogleMapsAutocompleteComponent.prototype, "autoCompleteOptions", void 0);
__decorate([
    Output()
], MatGoogleMapsAutocompleteComponent.prototype, "onChange", void 0);
__decorate([
    Output()
], MatGoogleMapsAutocompleteComponent.prototype, "onAutocompleteSelected", void 0);
__decorate([
    Output()
], MatGoogleMapsAutocompleteComponent.prototype, "onGermanAddressMapped", void 0);
__decorate([
    Output()
], MatGoogleMapsAutocompleteComponent.prototype, "onLocationSelected", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatGoogleMapsAutocompleteComponent, [{
        type: Component,
        args: [{
                selector: 'mat-google-maps-autocomplete',
                exportAs: 'matGoogleMapsAutocomplete',
                template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent_1),
                        multi: true
                    }
                ],
                styles: [".full-width{width:100%}"]
            }]
    }], function () { return [{ type: ɵngcc1.MapsAPILoader }, { type: ɵngcc0.NgZone }]; }, { addressLabelText: [{
            type: Input
        }], placeholderText: [{
            type: Input
        }], requiredErrorText: [{
            type: Input
        }], invalidErrorText: [{
            type: Input
        }], appearance: [{
            type: Input
        }], autoCompleteOptions: [{
            type: Input
        }], onChange: [{
            type: Output
        }], onAutocompleteSelected: [{
            type: Output
        }], onGermanAddressMapped: [{
            type: Output
        }], onLocationSelected: [{
            type: Output
        }], value: [{
            type: Input
        }], address: [{
            type: Input
        }], searchElementRef: [{
            type: ViewChild,
            args: ['search']
        }], country: [{
            type: Input
        }], placeIdOnly: [{
            type: Input
        }], strictBounds: [{
            type: Input
        }], types: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
export { MatGoogleMapsAutocompleteComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIm5nOi9AYW5ndWxhci1tYXRlcmlhbC1leHRlbnNpb25zL2dvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS9saWIvY29tcG9uZW50L21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3hILE9BQU8sRUFBdUIsV0FBVyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ2hHLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDeEMsT0FBTyxFQUFDLDJCQUEyQixFQUFDLE1BQU0saUVBQWlFLENBQUM7QUFNNUcsTUFBTSxDQUFOLElBQVksVUFLWDtBQUxELFdBQVksVUFBVTtBQUNyQixJQUFDLG1DQUFxQixDQUFBO0FBQUMsSUFDdEIsMkJBQWEsQ0FBQTtBQUFDLElBQ2QsaUNBQW1CLENBQUE7QUFBQyxJQUNwQiwrQkFBaUIsQ0FBQTtBQUNuQixDQUFDLEVBTFcsVUFBVSxLQUFWLFVBQVUsUUFLckI7QUFlRCxJQUFhLGtDQUFrQywwQ0FBL0MsTUFBYSxrQ0FBa0M7QUFBRyxJQXFFaEQsWUFBb0IsYUFBNEIsRUFDNUIsTUFBYztBQUNwQyxRQUZzQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtBQUFDLFFBQzdCLFdBQU0sR0FBTixNQUFNLENBQVE7QUFBQyxRQWhFbkMscUJBQWdCLEdBQUcsU0FBUyxDQUFDO0FBQy9CLFFBRUUsb0JBQWUsR0FBRywwQkFBMEIsQ0FBQztBQUMvQyxRQUVFLHNC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RCxVQUU1RCxTQUFTLEVBQUUsY0FDVCxrQkFDRTtJQUFPLEVBQUUsaUJBQWlCO1lBQzFCO0NBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7SUFBa0MsQ0FBQyxrQkFDakUsS0FBSyxFQUFFLElBQUksY0FDWixVQUNGO2dCQUNGLENBQUMsSUFDVzttQkFBa0MsQ0E4TTlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtBQUFDLFNBL01ZLGtDQUFrQztBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE5nWm9uZSwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRvcnN9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7TWFwc0FQSUxvYWRlcn0gZnJvbSAnQGFnbS9jb3JlJztcbmltcG9ydCB7TWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlfSBmcm9tICcuLi9kaXJlY3RpdmVzL2FkZHJlc3MtdmFsaWRhdG9yL21hdC1hZGRyZXNzLXZhbGlkYXRvci5kaXJlY3RpdmUnO1xuaW1wb3J0IHtMb2NhdGlvbn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9sb2NhdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHtHZXJtYW5BZGRyZXNzfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCBQbGFjZVJlc3VsdCA9IGdvb2dsZS5tYXBzLnBsYWNlcy5QbGFjZVJlc3VsdDtcbmltcG9ydCBBdXRvY29tcGxldGVPcHRpb25zID0gZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZU9wdGlvbnM7XG5cbmV4cG9ydCBlbnVtIEFwcGVhcmFuY2Uge1xuICBTVEFOREFSRCA9ICdzdGFuZGFyZCcsXG4gIEZJTEwgPSAnZmlsbCcsXG4gIE9VVExJTkUgPSAnb3V0bGluZScsXG4gIExFR0FDWSA9ICdsZWdhY3knLFxufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtYXQtZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlJyxcbiAgZXhwb3J0QXM6ICdtYXRHb29nbGVNYXBzQXV0b2NvbXBsZXRlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9tYXQtZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF0R29vZ2xlTWFwc0F1dG9jb21wbGV0ZUNvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZVxuICAgIH1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBNYXRHb29nbGVNYXBzQXV0b2NvbXBsZXRlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgQFZpZXdDaGlsZCgnc2VhcmNoJylcbiAgcHVibGljIHNlYXJjaEVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG5cbiAgQElucHV0KClcbiAgYWRkcmVzc0xhYmVsVGV4dCA9ICdBZGRyZXNzJztcblxuICBASW5wdXQoKVxuICBwbGFjZWhvbGRlclRleHQgPSAnUGxlYXNlIGVudGVyIHRoZSBhZGRyZXNzJztcblxuICBASW5wdXQoKVxuICByZXF1aXJlZEVycm9yVGV4dCA9ICdUaGUgYWRkcmVzcyBpcyByZXF1aXJlZCc7XG5cbiAgQElucHV0KClcbiAgaW52YWxpZEVycm9yVGV4dCA9ICdUaGUgYWRkcmVzcyBpcyBub3QgdmFsaWQnO1xuXG4gIEBJbnB1dCgpXG4gIGFwcGVhcmFuY2U6IHN0cmluZyB8IEFwcGVhcmFuY2UgPSBBcHBlYXJhbmNlLlNUQU5EQVJEO1xuXG4gIEBJbnB1dCgpXG4gIHZhbHVlOiBQbGFjZVJlc3VsdDtcblxuICBASW5wdXQoKVxuICBhZGRyZXNzOiBQbGFjZVJlc3VsdCB8IHN0cmluZztcblxuICBASW5wdXQoKVxuICBjb3VudHJ5OiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICBASW5wdXQoKVxuICBwbGFjZUlkT25seT86IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgc3RyaWN0Qm91bmRzPzogYm9vbGVhbjtcblxuICBASW5wdXQoKVxuICB0eXBlcz86IHN0cmluZ1tdO1xuICAvLyB0eXBlczogc3RyaW5nW10gPSBbJ2FkZHJlc3MnXTtcblxuICBASW5wdXQoKVxuICB0eXBlPzogc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIGF1dG9Db21wbGV0ZU9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbnMgPSB7fTtcblxuICBAT3V0cHV0KClcbiAgb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxQbGFjZVJlc3VsdCB8IHN0cmluZyB8IG51bGw+ID0gbmV3IEV2ZW50RW1pdHRlcjxQbGFjZVJlc3VsdCB8IHN0cmluZyB8IG51bGw+KCk7XG5cbiAgQE91dHB1dCgpXG4gIG9uQXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxQbGFjZVJlc3VsdD4gPSBuZXcgRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0PigpO1xuXG4gIEBPdXRwdXQoKVxuICBvbkdlcm1hbkFkZHJlc3NNYXBwZWQ6IEV2ZW50RW1pdHRlcjxHZXJtYW5BZGRyZXNzPiA9IG5ldyBFdmVudEVtaXR0ZXI8R2VybWFuQWRkcmVzcz4oKTtcblxuICBAT3V0cHV0KClcbiAgb25Mb2NhdGlvblNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8TG9jYXRpb24+ID0gbmV3IEV2ZW50RW1pdHRlcjxMb2NhdGlvbj4oKTtcblxuXG4gIHByaXZhdGUgb25OZXdQbGFjZVJlc3VsdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIHByaXZhdGUgYWRkcmVzc1ZhbGlkYXRvcjogTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlID0gbmV3IE1hdFZhbGlkYXRlQWRkcmVzc0RpcmVjdGl2ZSgpO1xuXG4gIHB1YmxpYyBhZGRyZXNzU2VhcmNoQ29udHJvbDogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiBudWxsfSwgVmFsaWRhdG9ycy5jb21wb3NlKFtcbiAgICBWYWxpZGF0b3JzLnJlcXVpcmVkLFxuICAgIHRoaXMuYWRkcmVzc1ZhbGlkYXRvci52YWxpZGF0ZSgpXSlcbiAgKTtcblxuICBwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7XG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBtYXBzQVBJTG9hZGVyOiBNYXBzQVBJTG9hZGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmFkZHJlc3NWYWxpZGF0b3Iuc3Vic2NyaWJlKHRoaXMub25OZXdQbGFjZVJlc3VsdCk7XG5cbiAgICBjb25zdCBvcHRpb25zOiBBdXRvY29tcGxldGVPcHRpb25zID0ge1xuICAgICAgLy8gdHlwZXM6IFsnYWRkcmVzcyddLFxuICAgICAgLy8gY29tcG9uZW50UmVzdHJpY3Rpb25zOiB7Y291bnRyeTogdGhpcy5jb3VudHJ5fSxcbiAgICAgIHBsYWNlSWRPbmx5OiB0aGlzLnBsYWNlSWRPbmx5LFxuICAgICAgc3RyaWN0Qm91bmRzOiB0aGlzLnN0cmljdEJvdW5kcyxcbiAgICAgIC8vIHR5cGVzOiB0aGlzLnR5cGVzLFxuICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgfTtcblxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgIHRoaXMuY291bnRyeSA/IG9wdGlvbnMuY29tcG9uZW50UmVzdHJpY3Rpb25zID0ge2NvdW50cnk6IHRoaXMuY291bnRyeX0gOiBudWxsO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgIHRoaXMuY291bnRyeSA/IG9wdGlvbnMudHlwZXMgPSB0aGlzLnR5cGVzIDogbnVsbDtcblxuICAgIHRoaXMuYXV0b0NvbXBsZXRlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5hdXRvQ29tcGxldGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXRHb29nbGVNYXBzQXV0b2NvbXBsZXRlKCk7XG4gIH1cblxuICBwdWJsaWMgaW5pdEdvb2dsZU1hcHNBdXRvY29tcGxldGUoKSB7XG4gICAgdGhpcy5tYXBzQVBJTG9hZGVyXG4gICAgICAubG9hZCgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKHRoaXMuc2VhcmNoRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLmF1dG9Db21wbGV0ZU9wdGlvbnMpO1xuICAgICAgICBhdXRvY29tcGxldGUuYWRkTGlzdGVuZXIoJ3BsYWNlX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcGxhY2UgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCBwbGFjZTogUGxhY2VSZXN1bHQgPSBhdXRvY29tcGxldGUuZ2V0UGxhY2UoKTtcblxuICAgICAgICAgICAgY29uc3QgZ2VybWFuQWRkcmVzczogR2VybWFuQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgZ21JRDogcGxhY2UuaWQsXG4gICAgICAgICAgICAgIGljb246IHBsYWNlLmljb24sXG4gICAgICAgICAgICAgIHVybDogcGxhY2UudXJsLFxuICAgICAgICAgICAgICBwbGFjZUlEOiBwbGFjZS5wbGFjZV9pZCxcbiAgICAgICAgICAgICAgZGlzcGxheUFkZHJlc3M6IHBsYWNlLmZvcm1hdHRlZF9hZGRyZXNzLFxuICAgICAgICAgICAgICBuYW1lOiBwbGFjZS5uYW1lLFxuICAgICAgICAgICAgICB2aWNpbml0eTogcGxhY2UudmljaW5pdHksXG4gICAgICAgICAgICAgIGxvY2FsaXR5OiB7fSxcbiAgICAgICAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICAgICAgICBjb3VudHJ5OiB7fSxcbiAgICAgICAgICAgICAgZ2VvTG9jYXRpb246IHtsYXRpdHVkZTogLTEsIGxvbmdpdHVkZTogLTF9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBsYWNlLmdlb21ldHJ5ICYmIHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MuZ2VvTG9jYXRpb24ubGF0aXR1ZGUgPSBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKTtcbiAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5nZW9Mb2NhdGlvbi5sb25naXR1ZGUgPSBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignc3RyZWV0X251bWJlcicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnN0cmVldE51bWJlciA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ3JvdXRlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RyZWV0TmFtZSA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZigncG9zdGFsX2NvZGUnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5wb3N0YWxDb2RlID0gTnVtYmVyKHZhbHVlLnNob3J0X25hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdzdWJsb2NhbGl0eScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnN1YmxvY2FsaXR5ID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdsb2NhbGl0eScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmxvY2FsaXR5LmxvbmcgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5sb2NhbGl0eS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnN0YXRlLmxvbmcgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdGF0ZS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ2NvdW50cnknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5jb3VudHJ5LmxvbmcgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5jb3VudHJ5LnNob3J0ID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8zJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MubG9jYWxpdHkuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vbkdlcm1hbkFkZHJlc3NNYXBwZWQuZW1pdChnZXJtYW5BZGRyZXNzKTtcblxuICAgICAgICAgICAgaWYgKCFwbGFjZS5wbGFjZV9pZCB8fCBwbGFjZS5nZW9tZXRyeSA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlLmdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIHBsYWNlIHJlc3VsdCBpcyBub3QgdmFsaWRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2hvdyBkaWFsb2cgdG8gc2VsZWN0IGEgYWRkcmVzcyBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAvLyBlbWl0IGZhaWxlZCBldmVudFxuICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcGxhY2U7XG4gICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBwbGFjZS5mb3JtYXR0ZWRfYWRkcmVzcztcbiAgICAgICAgICAgIHRoaXMub25BdXRvY29tcGxldGVTZWxlY3RlZC5lbWl0KHBsYWNlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkF1dG9jb21wbGV0ZVNlbGVjdGVkIC0+ICcsIHBsYWNlKTtcbiAgICAgICAgICAgIHRoaXMub25Mb2NhdGlvblNlbGVjdGVkLmVtaXQoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUubG9nKGVycikpO1xuICB9XG5cbiAgcHVibGljIG9uUXVlcnkoZXZlbnQ6IGFueSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdvbkNoYW5nZSgpJywgZXZlbnQpO1xuICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLmFkZHJlc3MpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldEFkZHJlc3MoKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gbnVsbDtcbiAgICB0aGlzLmFkZHJlc3NTZWFyY2hDb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAob2JqKSB7XG4gICAgICB0aGlzLnZhbHVlID0gb2JqO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZT8oaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG59XG4iXX0=