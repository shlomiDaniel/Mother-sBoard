import * as ɵngcc0 from '@angular/core';
var MatValidateAddressDirective_1;
import { __decorate } from "tslib";
import { Directive, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts
let MatValidateAddressDirective = MatValidateAddressDirective_1 = class MatValidateAddressDirective {
    constructor() {
    }
    validate() {
        return (control) => {
            return this.address ? null : {
                validateAddress: {
                    valid: false
                }
            };
        };
    }
    subscribe(eventEmitter) {
        this.subscription = eventEmitter.subscribe((address) => {
            this.address = address;
        });
    }
    unsubscribe() {
        this.subscription.unsubscribe();
    }
    get address() {
        return this._address;
    }
    set address(value) {
        this._address = value;
    }
};
MatValidateAddressDirective.ɵfac = function MatValidateAddressDirective_Factory(t) { return new (t || MatValidateAddressDirective)(); };
MatValidateAddressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatValidateAddressDirective, selectors: [["", "mat-address-validate", "", "formControlName", ""], ["", "MatValidateAddress", "", "formControl", ""], ["", "MatValidateAddress", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective_1), multi: true }
        ])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatValidateAddressDirective, [{
        type: Directive,
        args: [{
                selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective_1), multi: true }
                ]
            }]
    }], function () { return []; }, null); })();
export { MatValidateAddressDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWFkZHJlc3MtdmFsaWRhdG9yLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsibmc6L0Bhbmd1bGFyLW1hdGVyaWFsLWV4dGVuc2lvbnMvZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlL2xpYi9kaXJlY3RpdmVzL2FkZHJlc3MtdmFsaWRhdG9yL21hdC1hZGRyZXNzLXZhbGlkYXRvci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsT0FBTyxFQUFDLFNBQVMsRUFBZ0IsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2xFLE9BQU8sRUFBa0IsYUFBYSxFQUEyQyxNQUFNLGdCQUFnQixDQUFDO0FBR3hHLDZGQUE2RjtBQVE3RixJQUFhLDJCQUEyQixtQ0FBeEMsTUFBYSwyQkFBMkI7QUFBRyxJQU96QztBQUNGLElBQUUsQ0FBQztBQUNILElBQ1MsUUFBUTtBQUFLLFFBQ2xCLE9BQU8sQ0FBQyxPQUF3QixFQUEwQixFQUFFO0FBQ2hFLFlBQU0sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ25DLGdCQUFRLGVBQWUsRUFBRTtBQUN6QixvQkFBVSxLQUFLLEVBQUUsS0FBSztBQUN0QixpQkFBUztBQUNULGFBQU8sQ0FBQztBQUNSLFFBQUksQ0FBQyxDQUFBO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDUyxTQUFTLENBQUMsWUFBK0I7QUFDbEQsUUFBSSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFvQixFQUFFLEVBQUU7QUFDeEUsWUFBTSxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUM3QixRQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ1AsSUFBRSxDQUFDO0FBQ0gsSUFDUyxXQUFXO0FBQ3BCLFFBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUNwQyxJQUFFLENBQUM7QUFDSCxJQUNFLElBQUksT0FBTztBQUNiLFFBQUksT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3pCLElBQUUsQ0FBQztBQUNILElBQ0UsSUFBSSxPQUFPLENBQUMsS0FBSztBQUNuQixRQUFJLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQzFCLElBQUUsQ0FBQztBQUNILENBQUMsQ0FBQTtBQXJDWSwyQkFBMkIsb0RBTnZDLFNBQVMsQ0FBQyxVQUNULFFBQVEsRUFBRTs2RUFBeUcsVUFDbkgsU0FBUyxFQUFFLGNBQ1QsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsNkJBQTJCLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDLFVBQ2xHLE1BQ0YsQ0FBQyxJQUNXLDJCQUEyQixDQXFDdkM7Ozs7Ozs7Ozs7O2dEQUNEO0FBQUMsU0F0Q1ksMkJBQTJCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgUGxhY2VSZXN1bHQgPSBnb29nbGUubWFwcy5wbGFjZXMuUGxhY2VSZXN1bHQ7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZm9ybXMvc3JjL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy50c1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbWF0LWFkZHJlc3MtdmFsaWRhdGVdW2Zvcm1Db250cm9sTmFtZV0sW01hdFZhbGlkYXRlQWRkcmVzc11bZm9ybUNvbnRyb2xdLFtNYXRWYWxpZGF0ZUFkZHJlc3NdW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAge3Byb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hdFZhbGlkYXRlQWRkcmVzc0RpcmVjdGl2ZSksIG11bHRpOiB0cnVlfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hdFZhbGlkYXRlQWRkcmVzc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG5cbiAgcHVibGljIHN1YnNjcmlwdGlvbjogYW55O1xuXG4gIHByaXZhdGUgX2FkZHJlc3M6IFBsYWNlUmVzdWx0O1xuXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBwdWJsaWMgdmFsaWRhdGUoKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IGFueSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRyZXNzID8gbnVsbCA6IHtcbiAgICAgICAgdmFsaWRhdGVBZGRyZXNzOiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN1YnNjcmliZShldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSBldmVudEVtaXR0ZXIuc3Vic2NyaWJlKChhZGRyZXNzOiBQbGFjZVJlc3VsdCkgPT4ge1xuICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgZ2V0IGFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gIH1cblxuICBzZXQgYWRkcmVzcyh2YWx1ZSkge1xuICAgIHRoaXMuX2FkZHJlc3MgPSB2YWx1ZTtcbiAgfVxufVxuIl19