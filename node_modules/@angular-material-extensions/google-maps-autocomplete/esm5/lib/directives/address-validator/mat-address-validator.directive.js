import { __decorate } from "tslib";
import { Directive, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts
var MatValidateAddressDirective = /** @class */ (function () {
    function MatValidateAddressDirective() {
    }
    MatValidateAddressDirective_1 = MatValidateAddressDirective;
    MatValidateAddressDirective.prototype.validate = function () {
        var _this = this;
        return function (control) {
            return _this.address ? null : {
                validateAddress: {
                    valid: false
                }
            };
        };
    };
    MatValidateAddressDirective.prototype.subscribe = function (eventEmitter) {
        var _this = this;
        this.subscription = eventEmitter.subscribe(function (address) {
            _this.address = address;
        });
    };
    MatValidateAddressDirective.prototype.unsubscribe = function () {
        this.subscription.unsubscribe();
    };
    Object.defineProperty(MatValidateAddressDirective.prototype, "address", {
        get: function () {
            return this._address;
        },
        set: function (value) {
            this._address = value;
        },
        enumerable: true,
        configurable: true
    });
    var MatValidateAddressDirective_1;
    MatValidateAddressDirective = MatValidateAddressDirective_1 = __decorate([
        Directive({
            selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',
            providers: [
                { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return MatValidateAddressDirective_1; }), multi: true }
            ]
        })
    ], MatValidateAddressDirective);
    return MatValidateAddressDirective;
}());
export { MatValidateAddressDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWFkZHJlc3MtdmFsaWRhdG9yLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLW1hdGVyaWFsLWV4dGVuc2lvbnMvZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvYWRkcmVzcy12YWxpZGF0b3IvbWF0LWFkZHJlc3MtdmFsaWRhdG9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFDLFNBQVMsRUFBZ0IsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2xFLE9BQU8sRUFBa0IsYUFBYSxFQUEyQyxNQUFNLGdCQUFnQixDQUFDO0FBR3hHLDZGQUE2RjtBQVE3RjtJQU9FO0lBQ0EsQ0FBQztvQ0FSVSwyQkFBMkI7SUFVL0IsOENBQVEsR0FBZjtRQUFBLGlCQVFDO1FBUEMsT0FBTyxVQUFDLE9BQXdCO1lBQzlCLE9BQU8sS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDM0IsZUFBZSxFQUFFO29CQUNmLEtBQUssRUFBRSxLQUFLO2lCQUNiO2FBQ0YsQ0FBQztRQUNKLENBQUMsQ0FBQTtJQUNILENBQUM7SUFFTSwrQ0FBUyxHQUFoQixVQUFpQixZQUErQjtRQUFoRCxpQkFJQztRQUhDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxVQUFDLE9BQW9CO1lBQzlELEtBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLGlEQUFXLEdBQWxCO1FBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQsc0JBQUksZ0RBQU87YUFBWDtZQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN2QixDQUFDO2FBRUQsVUFBWSxLQUFLO1lBQ2YsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDeEIsQ0FBQzs7O09BSkE7O0lBaENVLDJCQUEyQjtRQU52QyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUseUdBQXlHO1lBQ25ILFNBQVMsRUFBRTtnQkFDVCxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsNkJBQTJCLEVBQTNCLENBQTJCLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO2FBQ2xHO1NBQ0YsQ0FBQztPQUNXLDJCQUEyQixDQXFDdkM7SUFBRCxrQ0FBQztDQUFBLEFBckNELElBcUNDO1NBckNZLDJCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBYnN0cmFjdENvbnRyb2wsIE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCBQbGFjZVJlc3VsdCA9IGdvb2dsZS5tYXBzLnBsYWNlcy5QbGFjZVJlc3VsdDtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21hc3Rlci9wYWNrYWdlcy9mb3Jtcy9zcmMvZGlyZWN0aXZlcy92YWxpZGF0b3JzLnRzXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttYXQtYWRkcmVzcy12YWxpZGF0ZV1bZm9ybUNvbnRyb2xOYW1lXSxbTWF0VmFsaWRhdGVBZGRyZXNzXVtmb3JtQ29udHJvbF0sW01hdFZhbGlkYXRlQWRkcmVzc11bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtcbiAgICB7cHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlKSwgbXVsdGk6IHRydWV9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yIHtcblxuICBwdWJsaWMgc3Vic2NyaXB0aW9uOiBhbnk7XG5cbiAgcHJpdmF0ZSBfYWRkcmVzczogUGxhY2VSZXN1bHQ7XG5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIHB1YmxpYyB2YWxpZGF0ZSgpOiBWYWxpZGF0b3JGbiB7XG4gICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgYW55ID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFkZHJlc3MgPyBudWxsIDoge1xuICAgICAgICB2YWxpZGF0ZUFkZHJlc3M6IHtcbiAgICAgICAgICB2YWxpZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3Vic2NyaWJlKGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyPGFueT4pIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGV2ZW50RW1pdHRlci5zdWJzY3JpYmUoKGFkZHJlc3M6IFBsYWNlUmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHVuc3Vic2NyaWJlKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBnZXQgYWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkcmVzcztcbiAgfVxuXG4gIHNldCBhZGRyZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkcmVzcyA9IHZhbHVlO1xuICB9XG59XG4iXX0=